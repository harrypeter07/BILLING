"use client";

import { db } from "@/lib/db/dexie";
import type { AuthSession } from "@/lib/db/dexie";
import CryptoJS from "crypto-js";

// Get session duration from env (default: 24 hours)
const SESSION_DURATION_MS =
	typeof process !== "undefined" && process.env.NEXT_PUBLIC_SESSION_DURATION_MS
		? parseInt(process.env.NEXT_PUBLIC_SESSION_DURATION_MS, 10)
		: 86400000; // 24 hours default

const SESSION_ID = "current_session";
// Client-side secret (different from server secret for additional security)
// Even if this is known, server validation will catch tampering
const CLIENT_SECRET =
	process.env.NEXT_PUBLIC_SESSION_SECRET ||
	"client-secret-key-change-in-production";

/**
 * Generate HMAC signature for session data to prevent tampering
 */
function generateSignature(sessionData: Omit<AuthSession, "id">): string {
	const dataString = JSON.stringify({
		userId: sessionData.userId,
		email: sessionData.email,
		role: sessionData.role,
		storeId: sessionData.storeId,
		issuedAt: sessionData.issuedAt,
		expiresAt: sessionData.expiresAt,
	});
	return CryptoJS.HmacSHA256(dataString, CLIENT_SECRET).toString();
}

/**
 * Verify session signature to detect tampering
 */
function verifySignature(
	session: AuthSession & { signature?: string }
): boolean {
	if (!session.signature) {
		// Legacy sessions without signature - invalidate them
		return false;
	}

	const sessionData: Omit<AuthSession, "id"> = {
		userId: session.userId,
		email: session.email,
		role: session.role,
		storeId: session.storeId,
		issuedAt: session.issuedAt,
		expiresAt: session.expiresAt,
		createdAt: session.createdAt,
	};

	const expectedSignature = generateSignature(sessionData);
	return session.signature === expectedSignature;
}

// Cache for server time to reduce API calls
let serverTimeCache: { time: number; timestamp: number } | null = null;
const SERVER_TIME_CACHE_DURATION = 30000; // Cache for 30 seconds

// Cache for server validation to reduce API calls
let serverValidationCache: { valid: boolean; timestamp: number } | null = null;
const SERVER_VALIDATION_CACHE_DURATION = 1800000; // Cache for 30 minutes (as requested)

/**
 * Get server time to prevent client-side time manipulation
 * CACHED: Only fetches from server if cache is older than 30 seconds
 * When online, we use client time (we have clock) to reduce API calls
 */
async function getServerTime(): Promise<number> {
	// When online, use client time (we have clock) - no need for server time
	// Server time is only needed for initial validation or when offline detection
	if (typeof window !== "undefined" && navigator.onLine) {
		// Check cache first
		if (serverTimeCache) {
			const age = Date.now() - serverTimeCache.timestamp;
			if (age < SERVER_TIME_CACHE_DURATION) {
				// Use cached server time (adjusted for elapsed time)
				return serverTimeCache.time + age;
			}
		}

		// Cache expired or doesn't exist - fetch once, then use client time
		// We only need server time occasionally to detect time manipulation
		try {
			const response = await fetch("/api/time", {
				method: "GET",
				cache: "no-store",
				signal: AbortSignal.timeout(2000), // 2 second timeout
			});
			if (response.ok) {
				const data = await response.json();
				if (data.timestamp) {
					// Cache the server time
					serverTimeCache = {
						time: data.timestamp,
						timestamp: Date.now(),
					};
					return data.timestamp;
				}
			}
		} catch (error) {
			// API unavailable, use client time
			console.warn(
				"[AuthSession] Server time API unavailable, using client time"
			);
		}
		// Use client time (we have clock when online)
		return Date.now();
	}

	// Offline: Use client time
	return Date.now();
}

/**
 * Enhanced session interface with signatures
 * serverSignature: Generated by server using SERVER_SECRET (not exposed to client)
 *                  This prevents offline tampering even if client secret is known
 */
interface SecureAuthSession extends AuthSession {
	signature?: string; // Client signature (using CLIENT_SECRET)
	serverSignature?: string; // Server signature (using SERVER_SECRET) - prevents offline bypass
	serverSignatureIssuedAt?: number; // When server signature was issued
	serverSignatureDataHash?: string; // Hash of session data when server signature was issued - prevents data modification
	lastValidated?: number;
	validationCount?: number;
}

/**
 * Get server signature for session data
 * This is called when session is created (online) to get server signature
 * Server signature uses SERVER_SECRET which is NOT exposed to client
 */
async function getServerSignature(
	sessionData: Omit<AuthSession, "id">
): Promise<string | null> {
	// Only get server signature if online
	if (typeof window === "undefined" || !navigator.onLine) {
		console.warn(
			"[AuthSession] Offline - cannot get server signature during session creation"
		);
		return null;
	}

	try {
		const response = await fetch("/api/auth/validate-session", {
			method: "POST",
			headers: { "Content-Type": "application/json" },
			body: JSON.stringify({
				sessionData: {
					userId: sessionData.userId,
					email: sessionData.email,
					role: sessionData.role,
					storeId: sessionData.storeId,
					issuedAt: sessionData.issuedAt,
					expiresAt: sessionData.expiresAt,
				},
				clientSignature: "", // Not needed for getting server signature
				clientTime: Date.now(),
				requestServerSignature: true, // Request server signature
			}),
			signal: AbortSignal.timeout(5000), // 5 second timeout
		});

		if (!response.ok) {
			console.warn(
				"[AuthSession] Failed to get server signature, will retry on validation"
			);
			return null;
		}

		const result = await response.json();
		if (result.serverSignature) {
			return result.serverSignature;
		}
		return null;
	} catch (error) {
		console.warn("[AuthSession] Error getting server signature:", error);
		return null;
	}
}

/**
 * Save authentication session to IndexedDB with cryptographic signatures
 *
 * SECURITY LAYERS:
 * 1. Client signature (using CLIENT_SECRET) - for basic validation
 * 2. Server signature (using SERVER_SECRET) - prevents offline bypass
 *
 * IMPORTANT: Server signature is obtained when session is created (online).
 * This signature cannot be regenerated by client because SERVER_SECRET is not exposed.
 * When validating offline, we check against stored server signature.
 */
export async function saveAuthSession(data: {
	userId: string;
	email: string;
	role: string;
	storeId?: string | null;
}): Promise<void> {
	const now = Date.now();
	const expiresAt = now + SESSION_DURATION_MS;

	const sessionData: Omit<AuthSession, "id"> = {
		userId: data.userId,
		email: data.email.toLowerCase(),
		role: data.role,
		storeId: data.storeId ?? null,
		issuedAt: now,
		expiresAt,
		createdAt: new Date().toISOString(),
	};

	// Generate client-side cryptographic signature
	const signature = generateSignature(sessionData);

	// CRITICAL: Get server signature when online (prevents offline bypass)
	// Server signature uses SERVER_SECRET which is NOT exposed to client
	// Even if attacker knows CLIENT_SECRET, they cannot regenerate server signature
	let serverSignature: string | null = null;
	let serverSignatureDataHash: string | null = null;
	if (typeof window !== "undefined" && navigator.onLine) {
		serverSignature = await getServerSignature(sessionData);
		if (serverSignature) {
			// Store hash of session data when server signature was issued
			// This allows us to detect if data is modified later
			serverSignatureDataHash = generateSessionDataHash(sessionData);
			console.log("[AuthSession] Server signature obtained and stored");
		} else {
			console.warn(
				"[AuthSession] Could not get server signature, session will be validated on next read"
			);
		}
	} else {
		console.warn(
			"[AuthSession] Offline during session creation - server signature will be obtained when online"
		);
	}

	const session: SecureAuthSession = {
		id: SESSION_ID,
		...sessionData,
		signature,
		serverSignature: serverSignature || undefined,
		serverSignatureIssuedAt: serverSignature ? now : undefined,
		serverSignatureDataHash: serverSignatureDataHash || undefined,
		lastValidated: now,
		validationCount: 0,
	};

	await db.auth_session.put(session as any);
	console.log(
		"[AuthSession] Session saved with signatures, expires at:",
		new Date(expiresAt).toISOString()
	);
}

/**
 * Generate hash of session data for integrity checking
 * This allows us to detect if session data was modified after server signature was issued
 */
function generateSessionDataHash(sessionData: Omit<AuthSession, "id">): string {
	const dataString = JSON.stringify({
		userId: sessionData.userId,
		email: sessionData.email,
		role: sessionData.role,
		storeId: sessionData.storeId,
		issuedAt: sessionData.issuedAt,
		expiresAt: sessionData.expiresAt,
	});
	// Use SHA256 for data integrity hash (not for security, just for change detection)
	return CryptoJS.SHA256(dataString).toString();
}

/**
 * Validate server signature offline
 * This prevents offline bypass by checking stored server signature
 * Server signature cannot be regenerated by client because SERVER_SECRET is not exposed
 */
function validateServerSignatureOffline(session: SecureAuthSession): boolean {
	// If no server signature stored, we can't validate (session created offline)
	if (!session.serverSignature) {
		console.warn(
			"[AuthSession] No server signature stored - session may have been created offline"
		);
		// For sessions created offline, we need to get server signature when online
		// For now, allow but mark for validation when online
		return true; // Allow but will be validated when online
	}

	// CRITICAL: Check if session data has been modified since server signature was issued
	// This prevents attacker from modifying data and keeping old server signature
	const currentSessionData: Omit<AuthSession, "id"> = {
		userId: session.userId,
		email: session.email,
		role: session.role,
		storeId: session.storeId,
		issuedAt: session.issuedAt,
		expiresAt: session.expiresAt,
		createdAt: session.createdAt,
	};

	const currentDataHash = generateSessionDataHash(currentSessionData);

	// If we have stored hash, compare it with current hash
	if (session.serverSignatureDataHash) {
		if (currentDataHash !== session.serverSignatureDataHash) {
			console.error(
				"[AuthSession] Session data modified after server signature was issued - tampering detected!"
			);
			return false; // Data was modified - reject session
		}
	} else {
		// Legacy session without data hash - store it now for future checks
		// This is safe because we're validating client signature too
		console.warn(
			"[AuthSession] No data hash stored, storing current hash for future validation"
		);
		session.serverSignatureDataHash = currentDataHash;
		// Don't save here, will be saved in getAuthSession
	}

	// Additional check: Verify server signature was issued recently (within session duration)
	if (session.serverSignatureIssuedAt) {
		const age = Date.now() - session.serverSignatureIssuedAt;
		const maxAge = SESSION_DURATION_MS * 2; // Allow up to 2x session duration
		if (age > maxAge) {
			console.warn("[AuthSession] Server signature too old, may need refresh");
			// Still allow but will be validated when online
		}
	}

	// All checks passed:
	// 1. Server signature exists (proves session was validated by server)
	// 2. Data hash matches (proves data hasn't been modified)
	// 3. Client signature is valid (validated in validateSessionWithServer)
	// This provides strong offline protection
	return true;
}

/**
 * Validate session with server (when online) or stored server signature (when offline)
 * OPTIMIZED: When online, only validates with server every 30 minutes to reduce API calls
 * This is the critical security check that prevents offline tampering
 */
async function validateSessionWithServer(
	session: SecureAuthSession
): Promise<boolean> {
	// First, always validate client signature
	if (!verifySignature(session)) {
		return false;
	}

	// If online, validate with server (but only every 30 minutes to reduce API calls)
	if (typeof window !== "undefined" && navigator.onLine) {
		// Check cache first - only validate with server every 30 minutes
		const now = Date.now();
		if (serverValidationCache) {
			const age = now - serverValidationCache.timestamp;
			if (age < SERVER_VALIDATION_CACHE_DURATION) {
				// Use cached validation result (no API call)
				console.log(
					"[AuthSession] Using cached server validation (last checked",
					Math.round(age / 1000),
					"seconds ago)"
				);
				// Still validate offline signature for integrity
				return validateServerSignatureOffline(session);
			}
		}

		// Cache expired or doesn't exist - validate with server
		try {
			const response = await fetch("/api/auth/validate-session", {
				method: "POST",
				headers: { "Content-Type": "application/json" },
				body: JSON.stringify({
					sessionData: {
						userId: session.userId,
						email: session.email,
						role: session.role,
						storeId: session.storeId,
						issuedAt: session.issuedAt,
						expiresAt: session.expiresAt,
					},
					clientSignature: session.signature,
					clientTime: now,
				}),
				signal: AbortSignal.timeout(3000), // 3 second timeout
			});

			if (!response.ok) {
				console.warn(
					"[AuthSession] Server validation failed, falling back to stored server signature"
				);
				// Fall through to offline validation
			} else {
				const result = await response.json();
				if (result.valid === true) {
					// Cache the validation result (valid for 30 minutes)
					serverValidationCache = {
						valid: true,
						timestamp: now,
					};

					// Server validated - update stored server signature if provided
					if (
						result.serverSignature &&
						result.serverSignature !== session.serverSignature
					) {
						session.serverSignature = result.serverSignature;
						session.serverSignatureIssuedAt = now;
						// Update data hash to match current session data
						const currentSessionData: Omit<AuthSession, "id"> = {
							userId: session.userId,
							email: session.email,
							role: session.role,
							storeId: session.storeId,
							issuedAt: session.issuedAt,
							expiresAt: session.expiresAt,
							createdAt: session.createdAt,
						};
						session.serverSignatureDataHash =
							generateSessionDataHash(currentSessionData);
						await db.auth_session.put(session as any);
						console.log("[AuthSession] Server signature updated");
					}

					// Also validate offline signature for integrity
					return validateServerSignatureOffline(session);
				}

				// Server validation failed - clear cache
				serverValidationCache = null;
				return false;
			}
		} catch (error) {
			console.warn(
				"[AuthSession] Server validation unavailable, using stored server signature:",
				error
			);
			// Fall through to offline validation
		}
	}

	// OFFLINE: Validate using stored server signature (no API calls)
	// This prevents offline bypass because:
	// 1. Server signature was obtained when online (using SERVER_SECRET)
	// 2. SERVER_SECRET is NOT exposed to client
	// 3. Attacker cannot regenerate server signature even if they know CLIENT_SECRET
	// 4. Data hash ensures data hasn't been modified

	console.log(
		"[AuthSession] Using stored server signature validation (offline or cached)"
	);
	return validateServerSignatureOffline(session);
}

/**
 * Get current authentication session from IndexedDB with validation
 *
 * SECURITY LAYERS:
 * 1. Client-side signature verification (works offline)
 * 2. Server-side validation (when online) - uses different secret
 * 3. Server time validation (prevents time manipulation)
 * 4. Expiry check with server time
 */
export async function getAuthSession(): Promise<AuthSession | null> {
	try {
		const session = (await db.auth_session.get(SESSION_ID)) as
			| SecureAuthSession
			| undefined;
		if (!session) {
			return null;
		}

		// LAYER 1: Client-side signature verification
		if (!verifySignature(session)) {
			console.error(
				"[AuthSession] Invalid client signature detected - possible tampering! Clearing session."
			);
			await clearAuthSession();
			return null;
		}

		// LAYER 2: Server-side validation (when online) OR stored server signature (when offline)
		// This is the critical check that prevents offline tampering
		//
		// ONLINE: Validates with server using SERVER_SECRET (not exposed to client)
		// OFFLINE: Validates using stored server signature obtained when online
		//
		// Why this works:
		// - Server signature uses SERVER_SECRET (not in client code)
		// - Even if attacker knows CLIENT_SECRET, they cannot regenerate server signature
		// - If session data is modified, server signature won't match (detected when online)
		// - Stored server signature proves session was validated by server at creation
		const serverValidation = await validateSessionWithServer(session);
		if (!serverValidation) {
			console.error(
				"[AuthSession] Server/stored signature validation failed - possible tampering! Clearing session."
			);
			await clearAuthSession();
			return null;
		}

		// LAYER 2.5: If online and server signature missing, get it now
		// This handles case where session was created offline
		if (
			typeof window !== "undefined" &&
			navigator.onLine &&
			!session.serverSignature
		) {
			console.log(
				"[AuthSession] Session missing server signature, obtaining now..."
			);
			const sessionData: Omit<AuthSession, "id"> = {
				userId: session.userId,
				email: session.email,
				role: session.role,
				storeId: session.storeId,
				issuedAt: session.issuedAt,
				expiresAt: session.expiresAt,
				createdAt: session.createdAt,
			};
			const newServerSignature = await getServerSignature(sessionData);
			if (newServerSignature) {
				session.serverSignature = newServerSignature;
				session.serverSignatureIssuedAt = Date.now();
				// Store hash of current session data
				session.serverSignatureDataHash = generateSessionDataHash(sessionData);
				await db.auth_session.put(session as any);
				console.log("[AuthSession] Server signature obtained and stored");
			}
		}

		// LAYER 3: Check expiry using client time (we have clock when online)
		// Server time is only fetched occasionally to detect time manipulation
		// This reduces API calls significantly
		const clientTime = Date.now();

		// Only check server time occasionally (every 30 seconds) when online
		// This reduces API calls while still detecting time manipulation
		let currentTime = clientTime;
		if (typeof window !== "undefined" && navigator.onLine) {
			// Check server time only if cache is old (reduces API calls)
			const serverTime = await getServerTime();
			const timeDifference = Math.abs(serverTime - clientTime);

			// Check for significant time manipulation (> 5 minutes difference)
			if (timeDifference > 300000) {
				// 5 minutes
				console.warn(
					"[AuthSession] Significant time difference detected:",
					timeDifference,
					"ms"
				);
				// Use server time if difference is significant
				currentTime = serverTime;
			} else {
				// Use client time (we have clock, no need for server time)
				currentTime = clientTime;
			}
		} else {
			// Offline: Use client time
			currentTime = clientTime;
		}
		if (currentTime > session.expiresAt) {
			console.log("[AuthSession] Session expired, clearing...");
			await clearAuthSession();
			return null;
		}

		// Update validation metadata
		session.lastValidated = currentTime;
		session.validationCount = (session.validationCount || 0) + 1;

		// Check for suspicious validation patterns
		if (session.validationCount > 1000) {
			console.warn("[AuthSession] Suspicious validation count detected");
			// Could implement rate limiting here
		}

		// Update data hash if missing (for legacy sessions)
		if (session.serverSignature && !session.serverSignatureDataHash) {
			const currentSessionData: Omit<AuthSession, "id"> = {
				userId: session.userId,
				email: session.email,
				role: session.role,
				storeId: session.storeId,
				issuedAt: session.issuedAt,
				expiresAt: session.expiresAt,
				createdAt: session.createdAt,
			};
			session.serverSignatureDataHash =
				generateSessionDataHash(currentSessionData);
		}

		// Save updated metadata
		await db.auth_session.put(session as any);

		// Return only the standard AuthSession interface
		return {
			id: session.id,
			userId: session.userId,
			email: session.email,
			role: session.role,
			storeId: session.storeId,
			issuedAt: session.issuedAt,
			expiresAt: session.expiresAt,
			createdAt: session.createdAt,
		};
	} catch (error) {
		console.error("[AuthSession] Error reading session:", error);
		return null;
	}
}

/**
 * Check if current session is valid (not expired)
 */
export async function isSessionValid(): Promise<boolean> {
	const session = await getAuthSession();
	return session !== null;
}

/**
 * Clear authentication session from IndexedDB
 */
export async function clearAuthSession(): Promise<void> {
	try {
		await db.auth_session.delete(SESSION_ID);
		// Clear caches when session is cleared
		serverTimeCache = null;
		serverValidationCache = null;
		console.log("[AuthSession] Session cleared from IndexedDB");
	} catch (error) {
		console.error("[AuthSession] Error clearing session:", error);
	}
}

/**
 * Get session expiry time in milliseconds
 */
export function getSessionDuration(): number {
	return SESSION_DURATION_MS;
}

/**
 * Check if session is expired (with server time validation)
 */
export async function isSessionExpired(
	session: AuthSession | null
): Promise<boolean> {
	if (!session) return true;

	// Re-fetch and validate signature
	const validatedSession = await getAuthSession();
	if (!validatedSession) return true;

	// Verify it's the same session
	if (
		validatedSession.userId !== session.userId ||
		validatedSession.email !== session.email
	) {
		return true;
	}

	// Check expiry with client time (we have clock, no need for server time on every check)
	// Server time is only used occasionally to detect time manipulation
	const clientTime = Date.now();
	return clientTime > session.expiresAt;
}
